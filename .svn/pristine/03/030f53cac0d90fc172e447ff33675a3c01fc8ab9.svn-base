import datetime
import json

from django.core.urlresolvers import reverse
from django.db import models

# Import External Models
from healthnet.core.users.user import User, UserType
from healthnet.core.users.patient import Patient, Gender, MaritalStatus
from healthnet.core.users.doctor import Doctor
from healthnet.core.users.nurse import Nurse
from healthnet.core.users.administrator import Administrator
from healthnet.core.logging import LogEntry, LogLevel, Logging


class Address(models.Model):
    address_line_1 = models.CharField(max_length=255)
    address_line_2 = models.CharField(max_length=255, blank=True)
    city = models.CharField(max_length=255)
    state = models.CharField(max_length=255)
    zipcode = models.CharField(max_length=255)


class Hospital(models.Model):
    name = models.CharField(max_length=255)
    address = models.OneToOneField('Address')


class Calendar(models.Model):
    @staticmethod
    def get_appointments_for_attendee_for_day(attendee: User, date: datetime):
        apts = []
        for apt in attendee.appointment_set.all():
            if date.date() == apt.tstart.date():
                apts += [apt]
        return apts

    @staticmethod
    def get_appointments_json(attendee: User):
        apts = []
        for apt in attendee.appointment_set.all():
            apts += [
                {
                    'id': apt.pk,
                    'title': apt.name,
                    'description': apt.description,
                    'url': reverse('edit_appointment', kwargs={'pk': apt.pk}),
                    'start': apt.tstart.astimezone().strftime("%c"),
                    'end': apt.tend.astimezone().strftime("%c"),
                }
            ]
        return json.dumps(apts)

    @staticmethod
    def create_appointment(attendees, name, desc, start, end):
        apt = Appointment.objects.create(name=name, description=desc, attendees=attendees, tstart=start, tend=end)
        if Calendar.has_conflict(attendees, start, end):
            return False, 'Appointment could not be created because there was a conflict.'
        apt.save()

        Logging.info("Created appointment with pk '%s'" % str(apt.pk))

        return True, apt

    @staticmethod
    def update_appointment(appointment, attendees=None, name=None, desc=None, start=None, end=None):
        if type(appointment) == int:
            appointment = Appointment.objects.get(pk=appointment)

        if type(appointment) != Appointment:
            return False, 'Appointment could not be updated by the provided appointment is not an appointment'

        if attendees is not None:
            appointment.attendees = attendees
        if name is not None:
            appointment.name = name
        if desc is not None:
            appointment.desc = desc
        if start is not None:
            appointment.start = start
        if end is not None:
            appointment.end = end

        Logging.info("Updated appointment with pk '%s'" % str(appointment.pk))
        return True, 'Appointment updated'

    @staticmethod
    def remove_appointment(appointment):
        if type(appointment) == int:
            appointment = Appointment.objects.get(pk=appointment)

        if type(appointment) != Appointment:
            return False, 'Appointment could not be updated by the provided appointment is not an appointment'

        appointment.delete()

        Logging.info("Deleted appointment named '%s' with pk '%s'" % (appointment.name, str(appointment.pk)))

        return True, 'Appointment deleted'

    @staticmethod
    def has_conflict(attendees, start, end, ignore_apt=None):
        attendees = set(attendees)

        for apt in Appointment.objects.all():
            if ignore_apt is not None and apt.pk == ignore_apt.pk:
                continue

            if set(apt.attendees.all()).intersection(attendees):
                if (apt.tstart > start) and (apt.tstart < end) or \
                                (apt.tend > start) and (apt.tstart < end) or \
                                (apt.tstart < start) and (apt.tend > end):
                    return True
        return False


class Appointment(models.Model):
    name = models.CharField(max_length=255)
    description = models.CharField(max_length=255)
    tstart = models.DateTimeField()
    tend = models.DateTimeField()
    attendees = models.ManyToManyField(User)

    def has_conflict(self):
        return Calendar.has_conflict(self.attendees.all(), self.tstart, self.tend, self)


class Prescription(models.Model):
    patient = models.OneToOneField('Patient')
    doctor = models.OneToOneField('Doctor')
    address = models.OneToOneField('Address')
    name = models.CharField(max_length=255)
    expiration_date = models.DateField()
    refills = models.IntegerField()


class MedicalRecord(models.Model):
    pass
